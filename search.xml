<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《把时间当作朋友》读书笔记]]></title>
    <url>%2F2017%2F03%2F13%2F%E3%80%8A%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[把时间当做朋友##一、单向成立 ####名人的成功经验有毒 正确的顺序是因素导致结果。成功的方式是不唯一的，导致成功的因素显然不是导致结果的充分且必要条件。坦白来讲，除了努力，聪明等优秀品质之外，机遇，运气，背景等偶然因素。 成功 = 必然因素 + 偶然因素。成功是各种因素的加权，方式不具备唯一性。 成功是一系列因素的加权之和，其方式不具备唯一性。很多因素并非充分必要条件。因此所谓名人采访，是一种从结果出发的倒退，不具备普遍性，只是单向成立而已。故而不能把成功者的经验当做一种信仰和教条。“欲练此功，必先自宫”的后一句“就算自宫也未必成功” 主观放大某些因素 因素A是助推成功的因素之一，但A是否是必要和不可或缺性，是一个疑问。即使是必要因素，其所占权重往往会因为我们主观因素，过于提高或者降低其比重。因此制定计划时，不要拖入一个主观状态，最好的方式就是仔细考量，适当放慢脚步，去沉淀整个计划方案，避免因暂时性的头脑一热，制定出难以实践的行动计划。 回想一下，我们时常在听了某个励志演讲，或者捕获新的方法时，感觉醍醐灌顶，从而着急忙慌，忽略客观事实和自身不足来制定不可行的计划。 slow down and think again.不仅仅不要冲动消费，也不要冲动计划。 “因为A所以B”的逻辑错误 如果一个人是正确的，他的世界也是正确的。这是一种逻辑错误，是偷换概念。 爱迪生的案例告诉他的成功很大愿意是因为努力和勤奋，但无法证明你像爱迪生一样努力就一定能成功。不忽略因素的重要性，但更要思考因为A所以B成立的逻辑性。 二、做好与兴趣顺序错误（是先做好了才更有兴趣，而非没有兴趣所以做不好） 做不好是因为不感兴趣是比较狭隘的。不感兴趣的原因很大程度是因为你没有做好，所以学习的过程很苦恼，但结果的不良反馈加深了你不的不感兴趣，这实际就是一种不良的反馈循环。 同样反过来，努力做好，用良好的结果刺激来让你享受这个事物，从而形成反馈来确保你的兴趣。这就是一个良性循环。 很多人是没有能力做好才说不感兴趣，不自觉的回避自己的短处，如果该事物是你不得不的选择，无论热爱与否，just do it, you will love it. 三、“方法技巧”与“坚持耐心”####方法很重要，但成功的核心是坚持和耐心 方法和坚持是成功的两大因素，但坚持本身就是最重要的方法。如果没有坚持，再好的方法也是无用功。 半途而废本身就是虚度时间 ####错误的方法论 过于强调方法论，一事无成的根本原因是因为放弃，放弃的理由之一就是换一个更好的方法和方向。你在行进的过程中会不断发现更好的方法，但更好的方法本身是不存在的。所以比起方法，最好的方式是先经过一段时间的坚持，然后再调整方法，以免在不断的调整方向中迷失了方向，最终放弃。 坚持到底未必成功，但失败归根结底就是“半途而废”。 初始阶段，计划的不可靠性。 初始状态，在没有行动经验时是没有能力制定合理有效的计划的，所以最好的方式就是先坚持，入门，然后熟悉，再摸索，反思，调整到最后找到合适的方法，直到成功。再没有初始认知时，一切都是空谈。所谓的计划不如变化，大抵如此。 先行动，行动中打磨计划 四、认知偏差（愿望中的我，真实的我，感觉的我）最理想的状态 愿望中的我 = 真实的我 = 感觉的我 特别的受挫和自卑愿望中的我 &gt;&gt; 现实的我 || 愿望中的我 &gt;&gt; 感觉的我 自负感觉的我 &gt;&gt; 真实的我 五、时间预算制定时间规划时，要留有部分空间来缓冲意外时间的发生吃青蛙战略：困难的事情优先做，擅长的事情放到后面是优势策略；养成时间记录的习惯，记录时间花费，线性追踪任何事情之前，先花费时间去分析完成任务的技能，做出宏观规划，1. 明白欠缺部分 2. 测算时间花费 3. 分析所需技能 4. 明确优缺点和擅长与否 明白时间不是百分百高效，合理安排 六、名言的价值很有明明很有道理的名言却很难有效传递。究其根本是由于这些经验需要很长的时间总结得来，所以听者缺乏现有的经验去感受，没有相似的经历去类比，所以很难形成有效的传递。 七、起始的偏差对全局的影响 对初始条件的敏感性依赖，同端点的射线，随着时间的延长，其差距愈加明显。蝴蝶效应中，某一个蝴蝶翅膀的震动导致飓风。起始阶段，微乎其微的差异在最终位置会造成指数级的差别。 习惯不同就决定人处于不同的起始阶段，所以习惯具有放大性。 八、独特性的分量 独特性并不等同于稀缺性每个人都是独特的，这是客观事实。但就因为每个人都很特殊，这是一种普遍的独特性，不具备稀缺性，所以大部分人仍属于具有完全独特性的芸芸众生中里的一份子。无它。 大多数事情符合正太分布，决定你与众不同的是，你落在了正态分布的两侧。完美主义者的失败 完美主义者的拖延过于完美主义会导致拖延 完美主义者的付出代价 学习氛围根据入门和瓶颈两个节点分为入门期，线性增长期和瓶颈期。等同时间的付出，在不同阶段获得的会把不同，最大的价值是在线性增长阶段（入门之后，瓶颈期之前），在瓶颈期付出很大的时间代价，往往只能获得很少的结果反馈。 因此在非专业领域的“不求甚解”往往是一种睿智的选择。但也要注意，高手之间的细小差距不是短时间就能追赶的，百米比赛中0.1s的确是明显的差距。 你没有克服XX，只是习惯了XX你没有克服拖延，只是习惯了拖延；你没有克服懒惰，只是习惯了懒惰；你没有明白无知，只是习惯了无知；]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对，我就是RunLoop]]></title>
    <url>%2F2016%2F06%2F08%2Frunloop%2F</url>
    <content type="text"><![CDATA[“请问你是？”“不用请问，我就是RunLoop”“你好，我是iOS开发者，我听说过你，不过抱歉，对你的名声我早有耳闻，只是不很熟悉。””嗯，不难理解。毕竟我在幕后，你在台前，我是说句不妄言的话，没有我，你们就别想玩的转。“”哦 ？ 这么说的话，我确实很好奇，请问你能不能介绍下你自己！ RunLoop的概念“人如其名，我就是RunLoooooooooooooooop,像是一个死循环，不停的跑圈，不停的跑圈，永远不知道疲倦。除非程序不启动，不然我永远不会停下来，当然如果是你们代码写的太差，有crash,那我也不得不停止了。”说点官方的，我其实是消息机制的处理模式，其实我一直在循环检测，从线程start到线程end，检测inputSource(如点击，双击等操作)同步事件，检测timeSource同步事件，检测到输入源会执行处理函数，首先会产生通知，CoreFunction向线程添加runLoop observers来监听事件，意在监听事件发生时来做处理。 可是程序启动与否和你有什么关系？程序启动伊始，有一段代码 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([YourAppDelegate class])); &#125;&#125; 这段代码永远不会真正停止，不然程序结束了，程序也停止了。所以我伴随着程序的启动，一直存在。当然，我不可能无意义的瞎跑。我贯穿整个程序，在奔跑的过程中帮忙处理各种事情。 我主观上听明白了你的意思，但冒昧的说一句，除了瞎跑我还真不知道你到底做了啥？我理解，我理解，毕竟你们花费大量的时间和UIKit和Foundation的各种类打交道，丝毫不估计我的存在感。但你有没有好奇过，你的事件响应，各种手势识别，定时器都是怎么传递的啊？抱歉，你这么一问，我确实欠考虑了。对啊，所以这就是我从幕后走向台前的目的。写代码不能只看表面，还要挖挖本质。我不停的run,也在不断在做事情，主要负责两大块东西:input Source 和 Timer Source。 RunLoop和线程之间的关系麻烦停一下，我只知道很多事情是线程来做的，比如页面的刷新交给主线程，异步线程来下载东西。但听你的口气，这些功劳都是你的了？对，从表面看来就是如此，但是你还是只关注了表面不是。我和线程是绑定在一起的。每个线程（包括主线程）都有一个对应的 Runloop 对象。只是你们并不能自己创建 Runloop 对象，但是可以获取到系统提供的 Runloop 对象。 主线程（也是你们常说的UI线程）的 Runloop 会在应用启动时完成启动，其他线程的 Runloop 默认并不会启动，只是在需要使用时，你们手动启动。 RunLoop不同的Mode 你的意思是，每一个线程都有一个RunLoop，但默认情况下只有主线程的才会开启。对，不仅每个线程都有RunLoop，而且每一个 RunLoop都包含若干个 Mode，怎么给你解释呢，你肯定玩过LOL吧，知道里面有鞋子的装备吧。这个倒忘不掉。那就好说了，你知道正常来说，每个人都只会买一种鞋子对不对，每个鞋子都有自己偏重的功能属性。我也一样，我有多个Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，就像每次你只能穿一种鞋一样，当然这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。就像换鞋子一样，必须先脱掉旧鞋才能穿上新鞋。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。其实每个Source/Timer/Observer都是Mode的不同item,item不同，Mode也不同，主要可以分为五类。 12345NSDefaultRunLoopMode //大多数工作中默认的运行方式NSConnectionReplyMode //使用这个Mode去监听NSConnection对象的状态，我们很少需要自己使用这个ModeNSModalPanelRunLoopMode //在Model Panel情况下去区分事件(OS X开发中会遇到)NSEventTrackingRunLoopMode //跟踪来自用户交互的事件（比如UITableView上下滑动）NSRunLoopCommonModes //这是一个伪模式，其为一组run loop mode的集合 但是iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。 这里就有点抽象了，这么多Mode你是怎么选择的呢？既然你觉得抽象，我再拿LOL里的鞋子给你举个栗子。最基础的鞋子能满足单纯走路的需要，只有你在想增加额外属性时，就需要合成新的鞋子。RunLoop也一样，通过增加item来组合完成一个新的Mode，默认情况下，在主线程开启默认状态就是NSDefaultRunLoopMode，可以举一个具体的例子么？比如在滑动tableView，会从默认的NSDefaultRunLoopMode 切换为NSEventTrackingRunLoopMode，当滑动停止时，又切换为NSDefaultRunLoopMode。 RunLoop的内部逻辑 哈哈，果真我对你了解的太不到位了，原来你是超神的存在。不不不，超神不至于，其实我也只是给系统跑腿罢了。但我的一举一动也要接受管理，不能随便乱来。谁还能管的了你啊？怎么管不了，能力大，责任大。我要时时刻刻接受系统的监督。你们对我的了解可能从NSRunLoop开始的，但这实际只是OC对我简单的封装，我的底层是C语言库CFRunLoop，这里面有一个叫CFRunLoopObserverRef的观察者，也就是前面我给你提到的Observer，当我的状态发生改变时，观察者就会记录我的变化。 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 这个倒不难理解，毕竟UIView，UIController，UIApplication都有类似的管理。对 RunLoop与NSTimer可是RunLoop与NSTimer有什么关系呢？NSTimer其实是一种资源，但它要想起作用必须添加到runLoop中。NSTimer会是准时触发事件吗？timer不是一种实时的机制，会存在延迟，而且延迟的程度跟当前线程的执行情况有关。这个怎么理解？正常情况下，你指定一个事件2秒之后触发，但若是此时恰好有一个大规模的连续耗时运算，那timer的执行必然要等到该连续事件处理结束才会开始执行，此时你就无法保证NSTimer的准时触发了。当然这只是针对于一次执行的timer，1[NSTimer scheduledTimerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES]; 对于重复性事件，情况也不一样。比如一个程序，你设置了周期性1秒触发，但是有个耗时事件用时两秒，此时就无法准确触发，并且以后会随着这个延迟继续延迟 ==周期性时间需要跑程序验证并打印出来== RunLoop的相关实战 说了那么多，我大约感受到你的神奇魔力了，但还是过于抽象和偏理论，有没有具体的实例来彰显你的存在感啊！那是必然，那我虎躯一震，抖一抖我的黑魔法。给你说几个具体的场景吧。 AutoreleasePool的真谛从MRC的手动释放内存，到ARC下我们不用手动管理，关键是因为什么？因为多了AutoreleasePool，自动释放池。但我也不知道AutoreleasePool背后到底帮助我们做了什么？其实这也和我RunLoop有关系，在App启动后，会在主线程度的RunLoop帮我们创建两个Observer。第一个 Observer 只监视了一个事件：监听事件在Entry(即将进入Loop)期间，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。第二个 Observer 监视了两个事件：在BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的，被这些inputSource和timeSource包裹。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。你这么一说我就理解了，难怪之前有人告诉我，内存的释放是在每次RunLoop结束之后呢。 performSelecter:afterDelay: 这算是一个场景，再给你说一个更具体的。好的，你说。你有没有遇到过这样的场景，我在子线程中执行performSelecter:，一切ok，但加了延时，执行performSelecter:afterDelay:方法时，但愣是没反应？对对对，后来别人说是给我在子线程开了RunLoop就ok了，我当时也是云里雾里的。其实这和NSTimer有关，当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。而子线程默认没有开启RunLoop，就无法执行timer事件，自然就不执行。原来如此。 GCD 既然聊到了线程问题，我想问下线程之间的通信问题。比如我在异步子线程执行了网络请求，想把请求回来的结果通过异步主线程dispatch_async(dispatch_get_main_queue(), block)，的方式将block回调给主线程，这应该也很你们有关系吧。对的，对于子线程和主线程之间的通信。当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。]]></content>
      <tags>
        <tag>iOS RunLoop</tag>
      </tags>
  </entry>
</search>