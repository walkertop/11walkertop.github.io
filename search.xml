<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《把时间当作朋友》读书笔记]]></title>
    <url>%2F%E3%80%8A%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、单向成立名人的成功经验有毒 正确的顺序是因素导致结果。成功的方式是不唯一的，导致成功的因素显然不是导致结果的充分且必要条件。坦白来讲，除了努力，聪明等优秀品质之外，机遇，运气，背景等偶然因素。 成功 = 必然因素 + 偶然因素。成功是各种因素的加权，方式不具备唯一性。 成功是一系列因素的加权之和，其方式不具备唯一性。很多因素并非充分必要条件。因此所谓名人采访，是一种从结果出发的倒退，不具备普遍性，只是单向成立而已。故而不能把成功者的经验当做一种信仰和教条。“欲练此功，必先自宫”的后一句“就算自宫也未必成功” 主观放大某些因素 因素A是助推成功的因素之一，但A是否是必要和不可或缺性，是一个疑问。即使是必要因素，其所占权重往往会因为我们主观因素，过于提高或者降低其比重。因此制定计划时，不要拖入一个主观状态，最好的方式就是仔细考量，适当放慢脚步，去沉淀整个计划方案，避免因暂时性的头脑一热，制定出难以实践的行动计划。 回想一下，我们时常在听了某个励志演讲，或者捕获新的方法时，感觉醍醐灌顶，从而着急忙慌，忽略客观事实和自身不足来制定不可行的计划。 slow down and think again.不仅仅不要冲动消费，也不要冲动计划。 “因为A所以B”的逻辑错误 如果一个人是正确的，他的世界也是正确的。这是一种逻辑错误，是偷换概念。 爱迪生的案例告诉他的成功很大愿意是因为努力和勤奋，但无法证明你像爱迪生一样努力就一定能成功。不忽略因素的重要性，但更要思考因为A所以B成立的逻辑性。 二、做好与兴趣顺序错误（是先做好了才更有兴趣，而非没有兴趣所以做不好） 做不好是因为不感兴趣是比较狭隘的。不感兴趣的原因很大程度是因为你没有做好，所以学习的过程很苦恼，但结果的不良反馈加深了你不的不感兴趣，这实际就是一种不良的反馈循环。 同样反过来，努力做好，用良好的结果刺激来让你享受这个事物，从而形成反馈来确保你的兴趣。这就是一个良性循环。 很多人是没有能力做好才说不感兴趣，不自觉的回避自己的短处，如果该事物是你不得不的选择，无论热爱与否，just do it, you will love it. 三、“方法技巧”与“坚持耐心”方法很重要，但成功的核心是坚持和耐心 方法和坚持是成功的两大因素，但坚持本身就是最重要的方法。如果没有坚持，再好的方法也是无用功。 半途而废本身就是虚度时间 错误的方法论 过于强调方法论，一事无成的根本原因是因为放弃，放弃的理由之一就是换一个更好的方法和方向。你在行进的过程中会不断发现更好的方法，但更好的方法本身是不存在的。所以比起方法，最好的方式是先经过一段时间的坚持，然后再调整方法，以免在不断的调整方向中迷失了方向，最终放弃。 坚持到底未必成功，但失败归根结底就是“半途而废”。 初始阶段，计划的不可靠性。 初始状态，在没有行动经验时是没有能力制定合理有效的计划的，所以最好的方式就是先坚持，入门，然后熟悉，再摸索，反思，调整到最后找到合适的方法，直到成功。再没有初始认知时，一切都是空谈。所谓的计划不如变化，大抵如此。 先行动，行动中打磨计划 四、认知偏差（愿望中的我，真实的我，感觉的我）最理想的状态 愿望中的我 = 真实的我 = 感觉的我 特别的受挫和自卑愿望中的我 &gt;&gt; 现实的我 || 愿望中的我 &gt;&gt; 感觉的我 自负感觉的我 &gt;&gt; 真实的我 五、时间预算制定时间规划时，要留有部分空间来缓冲意外时间的发生吃青蛙战略：困难的事情优先做，擅长的事情放到后面是优势策略；养成时间记录的习惯，记录时间花费，线性追踪任何事情之前，先花费时间去分析完成任务的技能，做出宏观规划，1. 明白欠缺部分 2. 测算时间花费 3. 分析所需技能 4. 明确优缺点和擅长与否 明白时间不是百分百高效，合理安排 六、名言的价值很有明明很有道理的名言却很难有效传递。究其根本是由于这些经验需要很长的时间总结得来，所以听者缺乏现有的经验去感受，没有相似的经历去类比，所以很难形成有效的传递。 七、起始的偏差对全局的影响 对初始条件的敏感性依赖，同端点的射线，随着时间的延长，其差距愈加明显。蝴蝶效应中，某一个蝴蝶翅膀的震动导致飓风。起始阶段，微乎其微的差异在最终位置会造成指数级的差别。 习惯不同就决定人处于不同的起始阶段，所以习惯具有放大性。 八、独特性的分量 独特性并不等同于稀缺性每个人都是独特的，这是客观事实。但就因为每个人都很特殊，这是一种普遍的独特性，不具备稀缺性，所以大部分人仍属于具有完全独特性的芸芸众生中里的一份子。无它。 大多数事情符合正太分布，决定你与众不同的是，你落在了正态分布的两侧。完美主义者的失败 完美主义者的拖延过于完美主义会导致拖延 完美主义者的付出代价 学习氛围根据入门和瓶颈两个节点分为入门期，线性增长期和瓶颈期。等同时间的付出，在不同阶段获得的会把不同，最大的价值是在线性增长阶段（入门之后，瓶颈期之前），在瓶颈期付出很大的时间代价，往往只能获得很少的结果反馈。 因此在非专业领域的“不求甚解”往往是一种睿智的选择。但也要注意，高手之间的细小差距不是短时间就能追赶的，百米比赛中0.1s的确是明显的差距。 你没有克服XX，只是习惯了XX你没有克服拖延，只是习惯了拖延；你没有克服懒惰，只是习惯了懒惰；你没有明白无知，只是习惯了无知；]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释automaticallyAdjustsScrollViewInsets，extendedLayoutIncludesOpaqueBars，edgesForExtendedLayout的不同]]></title>
    <url>%2F%E8%A7%A3%E9%87%8AautomaticallyAdjustsScrollViewInsets%EF%BC%8CextendedLayoutIncludesOpaqueBars%EF%BC%8CedgesForExtendedLayout%E7%9A%84%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[从iOS7开始，控制器就默认添加了全屏属性，因此，你就有更多的方式去操作view的布局，具体用到的属性包括： edgesForExtendedLayout automaticallyAdjustsScrollViewInsets extendedLayoutIncludesOpaqueBars edgesForExtendedLayout我们可以根据以上属性设置view的铺满样式。想象一下，默认情况下，我们从一个普通的UIViewController跳转到一个UINavigationController，view默认的展示样式是从导航栏底部开始。但是你可以通过设置edgesForExtendedLayout为不同类型来控制view的样式(top, left, bottom, right)。 可以看一下例子：123UIViewController *viewController = [[UIViewController alloc] init];viewController.view.backgroundColor = [UIColor redColor];UINavigationController *mainNavigationController = [[UINavigationController alloc] initWithRootViewController:viewController]; 你没有设置edgesForExtendedLayout的值，其默认的值是UIRectEdgeAll，所以view是延伸到整个屏幕的高度。效果如下图： 如你所见，红色背景延伸到了状态栏（status bar）下面。假若你将 edgesForExtendedLayout的值设置为UIRectEdgeNone，意味着你告诉view不要讲其扩展到整个屏幕。其效果如下: 1234UIViewController *viewController = [[UIViewController alloc] init];viewController.view.backgroundColor = [UIColor redColor];viewController.edgesForExtendedLayout = UIRectEdgeNone;UINavigationController *mainNavigationController = [[UINavigationController alloc] initWithRootViewController:viewController]; 关于另外一个属性automaticallyAdjustsScrollViewInsets.这个属性属于UIScrollView或包含UIScrollView的控制器（比如UITableView继承自UIScrollView，UIWebView中也包含UIScrollView）。如果你想要你的view从导航栏底部开始，但是在滑动时，让其穿透到导航栏的底部。在这种情况下，如果你将edgesForExtendedLayout设置为UIRectEdgeNone，虽然可以从导航栏底部开始，但滑动时无法穿透到导航栏底部。 怎么办呢？ 这时候就显示出automaticallyAdjustsScrollViewInsets的作用了。如果你将edgesForExtendedLayout的值设置为UIRectEdgeAll，automaticallyAdjustsScrollViewInsets设置为YES(edgesForExtendedLayout默认为UIRectEdgeAll，automaticallyAdjustsScrollViewInsets默认就是YES),就能实现上述需求。具体如下图：上图是将edgesForExtendedLayout设置为UIRectEdgeAll，automaticallyAdjustsScrollViewInsets默认就是NO的情况)。 下图是将edgesForExtendedLayout设置为UIRectEdgeAll，automaticallyAdjustsScrollViewInsets默认就是YES的情况)(也就是系统默认情况) 关于另外一个属性。字面意思是：是否延伸到包含不透明的状态栏。 extendedLayoutIncludesOpaqueBars这个值是一个补充,默认值是NO;默认的苹果的状态栏（status bar）是透明的。如果状态栏不透明，这个试图就不回扩展到不透明的状态栏底部，除非将其值设置为YESThis value is just an addition to the previous ones. If the status bar is opaque, the views won’t be extended to include the status bar too, unless this parameter is YES.所以如果状态栏不透明，即使你设置edgesForExtendedLayout 为 UIRectEdgeAll，extendedLayoutIncludesOpaqueBars为NO(默认如此)，view不会延伸到状态栏底部的。 怎么判断UIScrollView在使用？iOS会抓取控制器view的第一个子视图，（也就是index = 0），如果是UIScrollView或者UIScrollView的子类，就可以使用上文描述的属性。 如果视图是普通的UIView，可以添加一个线来解决。1self.navigationController.navigationBar.translucent = NO;]]></content>
  </entry>
  <entry>
    <title><![CDATA[一篇文章全吃透—史上最全YYModel的使用详解]]></title>
    <url>%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%85%A8%E5%90%83%E9%80%8F%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8YYModel%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开篇说明：虽然网上有很多讲解YYModel使用方法的文章，包括YYModel作者也在github上对其做了使用说明。但在我实际使用过程中，依然发现文档的不完善，比如对于复杂的模型（如多层嵌套）讲解的仍不透彻，同时本文也会介绍一神器配合YYModel使用，让你感受分分钟搞定模型创建的酸爽。当然为了减少读者的学习成本，本会对YYModel作者的文档进行丰富和扩展。可在github上下载Demo，以便更直观了解各种使用场景详细代码。文章只要包含： 详解YYModel的多种使用场景 拓展插件，让你一分钟搞定所有的模型的创建和调用。 一、YYModel的使用场景1.简单的 Model 与 JSON 相互转换1234567891011121314151617// JSON:&#123; &quot;uid&quot;:123456, &quot;name&quot;:&quot;Harry&quot;, &quot;created&quot;:&quot;1965-07-31T00:00:00+0000&quot;&#125;// Model:@interface User : NSObject@property UInt64 uid;@property NSString *name;@property NSDate *created;@end@implementation User@end 12345// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:User *user = [User yy_modelWithJSON:json];// 将 Model 转换为 JSON 对象:NSDictionary *json = [user yy_modelToJSONObject]; JSON/Dictionary 中的对象类型与 Model 属性不一致时，YYModel 将会进行如下自动转换。自动转换不支持的值将会被忽略，以避免各种潜在的崩溃问题。 2.Model 属性名和 JSON 中的 Key 不相同1234567891011121314151617181920212223242526// JSON:&#123; &quot;n&quot;:&quot;Harry Pottery&quot;, &quot;p&quot;: 256, &quot;ext&quot; : &#123; &quot;desc&quot; : &quot;A book written by J.K.Rowing.&quot; &#125;, &quot;ID&quot; : 100010&#125;// Model:@interface Book : NSObject@property NSString *name;@property NSInteger page;@property NSString *desc;@property NSString *bookID;@end@implementation Book//返回一个 Dict，将 Model 属性名对映射到 JSON 的 Key。+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@&quot;name&quot; : @&quot;n&quot;, @&quot;page&quot; : @&quot;p&quot;, @&quot;desc&quot; : @&quot;ext.desc&quot;, @&quot;bookID&quot; : @[@&quot;id&quot;,@&quot;ID&quot;,@&quot;book_id&quot;]&#125;;&#125;@end 你可以把一个或一组 json key (key path) 映射到一个或多个属性。如果一个属性没有映射关系，那默认会使用相同属性名作为映射。在 json-&gt;model 的过程中：如果一个属性对应了多个 json key，那么转换过程会按顺序查找，并使用第一个不为空的值。在 model-&gt;json 的过程中：如果一个属性对应了多个 json key (key path)，那么转换过程仅会处理第一个 json key (key path)；如果多个属性对应了同一个 json key，则转换过过程会使用其中任意一个不为空的值。 3.Model 包含其他 Model12345678910111213141516171819202122232425// JSON&#123; &quot;author&quot;:&#123; &quot;name&quot;:&quot;J.K.Rowling&quot;, &quot;birthday&quot;:&quot;1965-07-31T00:00:00+0000&quot; &#125;, &quot;name&quot;:&quot;Harry Potter&quot;, &quot;pages&quot;:256&#125;// Model: 什么都不用做，转换会自动完成@interface Author : NSObject@property NSString *name;@property NSDate *birthday;@end@implementation Author@end@interface Book : NSObject@property NSString *name;@property NSUInteger pages;@property Author *author; //Book 包含 Author 属性@end@implementation Book@end 4.容器类属性1234567891011121314151617@class Shadow, Border, Attachment;@interface Attributes@property NSString *name;@property NSArray *shadows; //Array&lt;Shadow&gt;@property NSSet *borders; //Set&lt;Border&gt;@property NSMutableDictionary *attachments; //Dict&lt;NSString,Attachment&gt;@end@implementation Attributes// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@&quot;shadows&quot; : [Shadow class], @&quot;borders&quot; : Border.class, @&quot;attachments&quot; : @&quot;Attachment&quot; &#125;;&#125;@end 在实际使用过过程中，[Shadow class]，Border.class，@&quot;Attachment&quot;没有明显的区别。这里仅仅是创建作者有说明，实际使用时，需要对其遍历，取出容器中得字典，然后继续字典转模型。（YYModel的核心是通过runtime获取结构体中得Ivars的值，将此值定义为key,然后给key赋value值，所以我们需要自己遍历容器（NSArray，NSSet，NSDictionary），获取每一个值，然后KVC）。 具体的代码实现如下： 12345678910111213NSDictionary *json =[self getJsonWithJsonName:@&quot;ContainerModel&quot;];ContainerModel *containModel = [ContainerModel yy_modelWithDictionary:json];NSDictionary *dataDict = [containModel valueForKey:@&quot;data&quot;];//定义数组，接受key为list的数组self.listArray = [dataDict valueForKey:@&quot;list&quot;]; //遍历数组[self.listArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSDictionary *listDict = obj; //获取数组中得字典 List *listModel = [List yy_modelWithDictionary:listDict]; //获取count 和 id NSString *count = [listModel valueForKey:@&quot;count&quot;]; NSString *id = [listModel valueForKey:@&quot;id&quot;]; 5.黑名单与白名单123456789101112131415@interface User@property NSString *name;@property NSUInteger age;@end@implementation Attributes// 如果实现了该方法，则处理过程中会忽略该列表内的所有属性+ (NSArray *)modelPropertyBlacklist &#123; return @[@&quot;test1&quot;, @&quot;test2&quot;];&#125;// 如果实现了该方法，则处理过程中不会处理该列表外的属性。+ (NSArray *)modelPropertyWhitelist &#123; return @[@&quot;name&quot;];&#125;@end 6.数据校验与自定义转换实际这个分类的目的比较简单和明确。就是对判断是否为时间戳，然后对时间戳进行处理，调用_createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue];获取时间。 1234567891011121314151617181920212223242526272829303132// JSON:&#123; &quot;name&quot;:&quot;Harry&quot;, &quot;timestamp&quot; : 1445534567 //时间戳&#125;// Model:@interface User@property NSString *name;@property NSDate *createdAt;@end@implementation User// 当 JSON 转为 Model 完成后，该方法会被调用。// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。// 你也可以在这里做一些自动转换不能完成的工作。- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic &#123; NSNumber *timestamp = dic[@&quot;timestamp&quot;]; if (![timestamp isKindOfClass:[NSNumber class]]) return NO; _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue]; return YES;&#125;// 当 Model 转为 JSON 完成后，该方法会被调用。// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。// 你也可以在这里做一些自动转换不能完成的工作。- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic &#123; if (!_createdAt) return NO; dic[@&quot;timestamp&quot;] = @(n.timeIntervalSince1970); return YES;&#125;@end 需要注意的时，如果用插件，对时间戳类型或默认创建为NSUInteger类型，需要将其更改为NSDate类型。 7.Coding/Copying/hash/equal/description以下方法都是YYModel的简单封装，实际使用过程和系统方法区别不大。对其感兴趣的可以点进方法内部查看。 123456789101112131415161718192021222324252627@interface YYShadow :NSObject &lt;NSCoding, NSCopying&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) CGSize size;@end@implementation YYShadow// 直接添加以下代码即可自动完成- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder]; &#125;- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; return [self yy_modelInitWithCoder:aDecoder]; &#125;- (id)copyWithZone:(NSZone *)zone &#123; return [self yy_modelCopy]; &#125;- (NSUInteger)hash &#123; return [self yy_modelHash]; &#125;- (BOOL)isEqual:(id)object &#123; return [self yy_modelIsEqual:object]; &#125;- (NSString *)description &#123; return [self yy_modelDescription]; &#125;@end - 二、ESJsonFormat与YYModel的结合使用彩蛋给大家介绍一款插件，配合ESJsonFormat 配图： 使用方法：快捷键：shift + control + J插件安装方法比较简单，在此不赘述，不知道可自行google。 好处： 可以直接将json数据复制，ESJsonFormat会根据数据类型自动生成属性。（建议还是要自行检查，比如时间戳，系统会默认帮你生成为NSUInteger，而我们想要的为NSDate类型） 对于多模型嵌套，不必创建多个文件，ESJsonFormat会自动在一个文件下创建多重类型,极其便捷。 至此YYModel的使用已讲解完毕，关于YYModel的底层核心是运用runtime获取类结构体中Ivars，进行KVC操作，然后根据不同情况进行分别处理。此处只是传递给大家一个概念，不展开讲解，网上有很多源码分析文章，可自学google学习。文末，做个综述。建议大家有时间一定要多看底层，分析源码。不要只会用，知其然不知其所以然。如有错误欢迎指出。]]></content>
      <tags>
        <tag>YYModel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC和runtime字典转模型对比分析]]></title>
    <url>%2FKVC%E5%92%8Cruntime%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文分为两部分： 一：教你怎样一部获取成员属性（通过NSObject+autoLogProperty分类）二：对比KVC和runtime两种字典转模型的方法并抽取一个分类 一：自定义分类，打印字典转模型的属性声明12345678910111213141516171819202122232425262728+ (void)createPropertyCodeWithDict:(NSDictionary *)dict&#123; NSMutableString *strM = [NSMutableString string]; // 遍历字典 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull propertyName, id _Nonnull value, BOOL * _Nonnull stop) &#123; NSString *code; //__NSCFString &lt;——&gt; NSString类型 //__NSCFNumber &lt;——&gt; int类型 //__NSCFArray &lt;——&gt; NSArray类型 //__NSCFDictionary &lt;——&gt; NSDictionary类型 //__NSCFBoolean &lt;——&gt; BOOL类型 if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSString *%@;&quot;,propertyName]; &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) int %@;&quot;,propertyName]; &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSArray *%@;&quot;,propertyName]; &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSDictionary *%@;&quot;,propertyName]; &#125;else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFBoolean&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) BOOL %@;&quot;,propertyName]; &#125; [strM appendFormat:@&quot;\n%@\n&quot;,code]; &#125;]; NSLog(@&quot;%@&quot;,strM);&#125; 1.核心思想：1.遍历自定义类中的成员变量 2.将遍历获取的成员变量定为value,复制给类中的ivar. 2.runtime字典转模型与KVC赋值的区别:KVC是调用`setValue: forKey: `的方法，将系统的成员变量作为value，自定义的属性为key 如果自定义的属性找不到就必须要调用 `- (void)setValue:(id)value forUndefinedKey:(NSString *)key;` 来处理报错。 但是runtime的字典转模型是将自定义属性生成的下划线成员变量变为key. `setValuesForKeysWithDictionary:`就不会出现找不到key而报错的问题了。 两种字典转模型的代码：1.KVC方式字典转模型12345678910111213141516+ (StatusModel *)statusWithDict:(NSDictionary *)dict&#123; StatusModel *statusModel = [[self alloc] init]; // KVC [statusModel setValuesForKeysWithDictionary:dict]; return statusModel;&#125;// 解决KVC报错- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;//可以为空，表示不处理，也可以为做一些转换操作// if ([key isEqualToString:@&quot;XXX&quot;]) &#123;// _### = [value integerValue];// &#125;&#125; 2.runtime字典转模型1234567891011121314151617181920212223242526272829303132333435363738394041424344+ (instancetype)modelWithDict:(NSDictionary *)dict &#123; id objc = [[self alloc] init]; unsigned int count = 0; Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; //获取属性名 Ivar ivar = ivarList[i]; //获取成员名 NSString *propertyName = [NSString stringWithUTF8String:ivar_getName(ivar)]; //获取key NSString *key = [propertyName substringFromIndex:1]; //取出下划线_ //获取字典中的value id value = dict[key]; //获取成员属性类型 NSString *propertyType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; //此处为二级转换，如果里面的为字典类型，且属性类型为二级模型的名字，不为NSDictionary if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![propertyType containsString:@&quot;NS&quot;]) &#123; // 需要字典转换成模型 // 转换成哪个类型 // 打印出来的值为 @&quot;@\&quot;User\&quot;&quot;, 截取成User // 字符串截取 NSRange range = [propertyType rangeOfString:@&quot;\&quot;&quot;]; propertyType = [propertyType substringFromIndex:range.location + range.length]; //此时变为 User\&quot;&quot;;,借着截取掉后面的\&quot;&quot; range = [propertyType rangeOfString:@&quot;\&quot;&quot;]; propertyType = [propertyType substringToIndex:range.location]; // 获取需要转换类的类对象 Class modelClass = NSClassFromString(propertyType); if (modelClass) &#123; value = [modelClass modelWithDict:value]; &#125; &#125; if (value) &#123; // KVC赋值:不能传空 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125; 3.具体使用123456789101112131415161718192021222324252627282930313233- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil]; NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:filePath]; //log方法属性 NSArray *dictArr = dict[@&quot;statuses&quot;]; [[self class] createPropertyCodeWithDict:dictArr[0]]; //打印StatusModel的属性 [[self class] createPropertyCodeWithDict:dictArr[0][@&quot;user&quot;]]; //打印UserModel的属性 NSMutableArray *statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123;// KVC字典转模型，调用setValueForKeyWithDictionary:方法// StatusModel *statusModel = [StatusModel statusWithDict:dict]; // runtime字典转模型，调用分类方法 StatusModel *statusModel = [StatusModel modelWithDict:dict]; [statuses addObject:statusModel]; &#125; NSLog(@&quot;%@&quot;,statuses); self.dataArray = statuses;&#125;//懒加载dataArray- (NSMutableArray *)dataArray&#123; if (!_dataArray) &#123; _dataArray = [NSMutableArray array]; &#125; return _dataArray;&#125; 点击下载demo 注意：demo中的工具类可以抽取使用]]></content>
      <tags>
        <tag>KVC Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对，我就是RunLoop]]></title>
    <url>%2Frunloop%2F</url>
    <content type="text"><![CDATA[1#以下是RunLoop和iOS搬砖程序员的访谈# “请问你是？” “不用请问，我就是RunLoop” “你好，我是iOS开发者，我听说过你，不过抱歉，对你的名声我早有耳闻，只是不很熟悉。” ”嗯，不难理解。毕竟我在幕后，你在台前，我是说句不妄言的话，没有我，你们就别想玩的转。“ ”哦 ？ 这么说的话，我确实很好奇，请问你能不能介绍下你自己！ RunLoop的概念人如其名，我就是RunLoooooooooooooooop,像是一个死循环，不停的跑圈，永不懈怠。除非程序不启动，或者你们代码写的太差，以至于crash,我才不得不停止了。 可是程序启动与否和你有什么关系？ 程序启动伊始，有一段代码：12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([YourAppDelegate class])); &#125;&#125; 这段代码永远不会执行结束，不然程序也停止了。所以我伴随着程序的启动，一直存在。当然，我不可能无意义的瞎跑。我贯穿整个程序，在奔跑的过程中帮忙处理各种事情。 我主观上听明白了你的意思，但冒昧的说一句，除了瞎跑我还真不知道你到底做了啥？ 我理解，我理解，毕竟你们花费大量的时间和UIKit和Foundation的各种类打交道，丝毫不顾及我的存在感。但你有没有好奇过，你的事件响应，各种手势识别，定时器都是怎么传递的啊？ 抱歉，你这么一问，我确实欠考虑了。 对啊，所以这就是我从幕后走向台前的目的。写代码不能只看表面，还要挖挖本质。话说回来，官方点说呢，我就是消息机制的处理模式，从线程start到线程end，一直在循环检测，检测inputSource(如点击，双击等操作)同步事件，检测timeSource同步事件，检测到输入源后会执行处理函数，首先会产生通知，CoreFunction向线程添加runLoop Observers来监听事件，意在监听事件发生时来做处理。 RunLoop和线程之间的关系 麻烦停一下，我只知道很多事情是线程来做的，比如页面刷新交给主线程，异步线程来下载。但听你的口气，这些功劳都是你的了？ 对，从表面看来你们都是在操作线程，但这只是表面。我和线程是绑定在一起的。每个线程都有一个对应的 Runloop 对象。当然不同线程的RunLoop是有区别的，主线程（也是你们常说的UI线程）的 Runloop 会在应用启动时完成启动，其他线程的 Runloop 默认并不会启动，只是在需要使用时，你们手动启动。 RunLoop不同的Mode 你的意思是，每一个线程都有一个RunLoop，但默认情况下只有主线程的才会开启。 对，不仅每个线程都有RunLoop，而且每一个 RunLoop都包含若干个 Mode，这么给你解释吧，你肯定玩过LOL吧，知道里面有鞋子的装备吧。 这个倒忘不掉。 那就好说了，正常来说，每个鞋子都有自己偏重的功能属性，不同英雄都只会买一种鞋子对不对。我也一样，我虽然有多个Mode，但就像穿鞋一样，每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 RunLoop，再重新指定一个 Mode 进入。这就像换鞋子一样，必须先脱掉旧鞋才能穿上新鞋。 当然，鞋子不同，有的偏重法术，有的偏重攻速，你所谓的Mode是怎么区分不同的？ 其实每个 Mode 包含若干个 Source/Timer/Observer，这些都属于Mode的item，item不同，Mode也不同，RunLoop分为五类。 12345NSDefaultRunLoopMode //大多数工作中默认的运行方式NSConnectionReplyMode //使用这个Mode去监听NSConnection对象的状态，我们很少需要自己使用这个ModeNSModalPanelRunLoopMode //在Model Panel情况下去区分事件(OS X开发中会遇到)NSEventTrackingRunLoopMode //跟踪来自用户交互的事件（比如UITableView上下滑动）NSRunLoopCommonModes //这是一个伪模式，其为一组run loop mode的集合 虽然模式很多，但iOS中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。 这里就有点抽象了，这么多Mode你是怎么选择的呢？ 主线程的 RunLoop 里有两个预置的 Mode：NSDefaultRunLoopMode和 NSEventTrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 但如果我想滑动ScrollView时，不影响Timer咋办？ 既然在DefaultMode下，不影响Timer，TrackingRunLoopMode下能滑动，两者都不影响，就是两种模式都要就ok了，iOS中的commonModeItems就是就是将DefaultMode和TrackingRunLoopMode组合在一起了，因此只用切换到commonModeItems就ok了。 RunLoop的内部逻辑 哈哈，果真我对你了解的太不到位了，原来你是超神的存在。 不不不，超神不至于，其实我也只是给系统跑腿罢了。但我的一举一动也要接受管理，不能随便乱来。 谁还能管的了你啊？ 怎么管不了，能力大，责任大。我要时时刻刻接受系统的监督。你们对我的了解可能从NSRunLoop开始的，但这实际只是OC对我简单的封装，我的底层是C语言库CFRunLoop，这里面有一个叫CFRunLoopObserverRef的观察者，也就是前面我给你提到的Observer，当我的状态发生改变时，观察者就会记录我的变化。 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 这个倒不难理解，毕竟UIView，UIController，UIApplication都有类似的管理。 RunLoop与NSTimer的准时触发 可是RunLoop与NSTimer有什么关系呢？ NSTimer其实是一种资源，但它要想起作用必须添加到RunLoop中。 NSTimer会是准时触发事件吗？ timer不是一种实时的机制，会存在延迟，而且延迟的程度跟当前线程的执行情况有关。 这个怎么理解？ 正常情况下，你指定一个事件2秒之后触发，但若是此时恰好有一个大规模的连续耗时运算，那timer的执行必然要等到该连续事件处理结束才会开始执行，此时你就无法保证NSTimer的准时触发了。当然这只是针对于一次执行的timer，1[NSTimer scheduledTimerWithTimeInterval:1 target:testObject2 selector:@selector(timerAction:) userInfo:nil repeats:YES]; 对于重复性事件，情况也不一样。比如一个程序，你设置了周期性1秒触发，但是有个耗时事件用时两秒，此时就无法准确触发，并且以后会随着这个延迟继续延迟。 RunLoop的相关实战 说了那么多，我大约感受到你的神奇魔力了，但还是过于抽象和偏理论，有没有具体的实例来彰显你的存在感啊！ 那是必然，那我虎躯一震，抖一抖我的黑魔法。给你说几个具体的场景吧。 AutoreleasePool的真谛问你个问题：从MRC的手动管理内存，到ARC的自动管理，其关键因素是什么？ 因为多了AutoreleasePool，自动释放池。只是我也不知道AutoreleasePool背后到底帮助我们做了什么？ 哈哈，其实这和我RunLoop有很大的关系，在App启动后，会在主线程度的RunLoop帮我们创建两个Observer。第一个 Observer 只监视了一个事件：监听事件在Entry(即将进入Loop)期间，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。第二个 Observer 监视了两个事件：在BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的，被这些inputSource和timeSource包裹。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 你这么一说我就理解了，难怪之前有人告诉我，内存的释放是在每次RunLoop结束之后呢。 这算是一个场景，当然还有其它的。 关于performSelecter:afterDelay:方法 好的，你接着说。 你有没有遇到过这样的场景，我在子线程中执行performSelecter:，一切ok，但加了延时，执行performSelecter:afterDelay:方法时，却愣是没反应？ 对对对，后来别人告诉我在子线程开了RunLoop就ok了，至于为何，我现在还是云里雾里的。 其实这和NSTimer有关，当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。而子线程默认没有开启RunLoop，就无法执行timer事件，自然就不执行。 原来如此。 GCD 既然聊到了线程问题，我想问下线程之间的通信问题。比如我在异步子线程执行了网络请求，想把请求回来的结果通过异步主线程dispatch_async(dispatch_get_main_queue(), block)，的方式将block回调给主线程，这应该也很你们有关系吧。 对的，对于子线程和主线程之间的通信。当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。]]></content>
      <tags>
        <tag>iOS RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看不会这篇就没脸说懂setter/getter]]></title>
    <url>%2F%E7%9C%8B%E4%B8%8D%E4%BC%9A%E8%BF%99%E7%AF%87%E5%B0%B1%E6%B2%A1%E8%84%B8%E8%AF%B4%E6%87%82setter-getter%2F</url>
    <content type="text"><![CDATA[背景setter/getter是一个类最基本的东西，任何一门面向对象的语言，都有这个概念，C++、java等等。因为setter/getter是对面向对象语言封装的最基本的支持。 OC中的setter/getter特点和变化OC的setter/getter和其他面向对象的语言没有什么不同。只不过，添加了一些自己的特性。 LLVM编译器下的setter/getter的实质。我们都知道@property实质帮我们做了setter、getter和生成_属性名的三部操作，具体情况是怎样的呢，下面三部将给你一一揭示@peroperty的实质。 Step1:成员变量首先查找是否有以_属性名命名的成员变量。 如果有，默认对其进行set和get； 如果没有，则隐式生成以_属性名命名的成员变量； 实际LLVM编译器会隐形的帮我们创建一个_属性名的成员变量。 &lt;不过注意，编译器会先检测有无相关成员变量，有不创建，无才创建，下文会有详细说明&gt; Step2:系统默认实现setter方法代码如下： 123- (void)setName:(NSString *)name &#123; _name = name;&#125; Step3:系统默认实现getter方法代码如下： 123- (NSString *)name &#123; return _name; //调用getter方法返回的是下划线的成员变量。&#125; 更改@property的_属性虽然系统默认帮助我们生成了属性名的成员变量，假如我们并不想如此，而是把系统的属性更改为制定的成员变量。接下来怎操作呢？实质上是由两种方法的，下面一一介绍: 方式一：重写setter/getter方法，将_属性名 更改为我们想要的名字； 方式二:直接使用@synthesize 属性名 = 指定属性名；两种创建方式的代码如下： 123456789101112131415161718192021222324252627282930313233343536@interface ViewController () &#123; NSString *mySynthesizeString2; //synthesize方法 NSString *setterString; //setter的string&#125;@property(nonatomic,copy) NSString *myString1;@property(nonatomic,copy) NSString *myString2; //@synthesize@property(nonatomic,copy) NSString *myString3;@end@implementation ViewController@synthesize myString1; //没有_myString1@synthesize myString2 = mySynthesizeString2; //将成员变量变为mySynthesizeString2- (void)viewDidLoad &#123; [super viewDidLoad]; &#125;/** * 通过重写setter方法改变成员变量的值 * * @param myString2 将自定义的成员变量setterString赋值给myString2， * 以后调setter实际获得的是setterString， _myString2 已不存在 */- (void)setMyString2:(NSString *)myString2 &#123; setterString = myString1;&#125;- (NSString *)myString2 &#123; return setterString;&#125; 关于@property的属性注意事项 使用属性注意事项： 1、当属性名与成员变量名一样时，如果我们想保证成员变量有值，那么就需要在.m中加入@synthesize 变量名； 2、当属性名与成员变量名一样时，如果我们对成员变量的值不强求，但我们又想打印所赋的值，这时在.m里可以使用(_属性名) 或者self.属性名； 3、当定义一个属性时，会首先查找是否有以 属性名 命名的成员变量，如果有，默认对其进行setter/getter，如果没有，则隐式生成以`属性名`命名的成员变量； 4、当我们使用属性时成员变量可以省略。(当.h文件中的成员变量名不省略时 .m文件中的@synthesize 也不能省略！当成员变量名省略时@synthesize也可以省略） 扩展关于setter,getter,readonly,readwrite（1）设置访问方法的名字默认的getter和setter器的名称是和变量名关联的，一定是setVirableName和virableName，比如上面的变量age，setter是setAge，getter是age。可以通过设置@property中的setter和getter属性来修改setter和getter器的方法名。getter=getterNamesetter=setterName 举个例子：@property (getter=show1,setter=show2:)int age;//现在，它的getter和setter的方法名字就变了注意：如果你设置了readonly属性的话，那么你就不应该设置setter属性，要不然会给出一个编译器的警告。 （2）设置只读或读写下面两个属性很好理解，readwrite：表示既有getter，也有setterreadonly：表示只有getter，没有setter这两个属性是互相排斥的，只能存在一个。]]></content>
      <tags>
        <tag>setter/getter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三分钟教会你runtime获取属性和成员变量]]></title>
    <url>%2F%E4%B8%89%E5%88%86%E9%92%9F%E6%95%99%E4%BC%9A%E4%BD%A0runtime%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[目录 成员变量和属性到底是什么？ 怎么通过runtime获取属性？ 怎么通过runtime获取成员变量？ 成员变量和属性的区别？ 实际应用场景是什么？ 成员变量1、成员变量的定义 Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针typedef struct objc_ivar *Ivar; 2、相关函数 // 获取所有成员变量class_copyIvarList// 获取成员变量名ivar_getName// 获取成员变量类型编码ivar_getTypeEncoding// 获取指定名称的成员变量class_getInstanceVariable// 获取某个对象成员变量的值object_getIvar// 设置某个对象成员变量的值object_setIvar 说明：property_getAttributes函数返回objc_property_attribute_t结构体列表，objc_property_attribute_t结构体包含name和value，常用的属性如下： 属性类型 name值：T value：变化编码类型 name值：C(copy) &amp;(strong) W(weak)空(assign) 等 value：无非/原子性 name值：空(atomic) N(Nonatomic) value：无变量名称 name值：V value：变化 使用property_getAttributes获得的描述是property_copyAttributeList能获取到的所有的name和value的总体描述，如 T@”NSDictionary”,C,N,V_dict1 3、实例应用1234567&lt;!--Person.h文件--&gt;@interface Person : NSObject&#123; NSString *address;&#125;@property(nonatomic,strong)NSString *name;@property(nonatomic,assign)NSInteger age; 123456789101112//遍历获取Person类所有的成员变量IvarList- (void) getAllIvarList &#123; unsigned int methodCount = 0; Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i ++) &#123; Ivar ivar = ivars[i]; const char * name = ivar_getName(ivar); const char * type = ivar_getTypeEncoding(ivar); NSLog(@&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;,type, name); &#125; free(ivars);&#125; 1234&lt;!--打印结果--&gt;2016-06-15 20:26:39.412 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 address 2016-06-15 20:26:39.413 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为@&quot;NSString&quot;，名字为 _name 2016-06-15 20:26:39.413 demo-Cocoa之method swizzle[17798:2565569] Person拥有的成员变量的类型为q，名字为 _age 属性1、属性的定义 objc_property_t：声明的属性的类型，是一个指向objc_property结构体的指针typedef struct objc_property *objc_property_t; 2、相关函数 // 获取所有属性class_copyPropertyList说明：使用class_copyPropertyList并不会获取无@property声明的成员变量// 获取属性名property_getName// 获取属性特性描述字符串property_getAttributes// 获取所有属性特性property_copyAttributeList 3、实例应用1234567&lt;!--Person.h文件--&gt;@interface Person : NSObject&#123; NSString *address;&#125;@property(nonatomic,strong)NSString *name;@property(nonatomic,assign)NSInteger age; 12345678910//遍历获取所有属性Property- (void) getAllProperty &#123; unsigned int propertyCount = 0; objc_property_t *propertyList = class_copyPropertyList([Person class], &amp;propertyCount); for (unsigned int i = 0; i &lt; propertyCount; i++ ) &#123; objc_property_t *thisProperty = propertyList[i]; const char* propertyName = property_getName(*thisProperty); NSLog(@&quot;Person拥有的属性为: &apos;%s&apos;&quot;, propertyName); &#125;&#125; 123&lt;!--打印结果--&gt;2016-06-15 20:25:19.653 demo-Cocoa之method swizzle[17778:2564081] Person拥有的属性为: &apos;name&apos;2016-06-15 20:25:19.653 demo-Cocoa之method swizzle[17778:2564081] Person拥有的属性为: &apos;age&apos; 应用具体场景1、Json到Model的转化在开发中相信最常用的就是接口数据需要转化成Model了（当然如果你是直接从Dict取值的话。。。），很多开发者也都使用著名的第三方库如JsonModel、Mantle或MJExtension等，如果只用而不知其所以然，那真和“搬砖”没啥区别了，下面我们使用runtime去解析json来给Model赋值。 原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法： 12345678910111213141516171819202122232425262728293031323334- (instancetype)initWithDict:(NSDictionary *)dict &#123; if (self = [self init]) &#123; //(1)获取类的属性及属性对应的类型 NSMutableArray * keys = [NSMutableArray array]; NSMutableArray * attributes = [NSMutableArray array]; /* * 例子 * name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3 * name = value4 attribute = T^i,N,V_value4 */ unsigned int outCount; objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = properties[i]; //通过property_getName函数获得属性的名字 NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [keys addObject:propertyName]; //通过property_getAttributes函数可以获得属性的名字和@encode编码 NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; [attributes addObject:propertyAttribute]; &#125; //立即释放properties指向的内存 free(properties); //(2)根据类型给属性赋值 for (NSString * key in keys) &#123; if ([dict valueForKey:key] == nil) continue; [self setValue:[dict valueForKey:key] forKey:key]; &#125; &#125; return self; &#125; 读者可以进一步思考： 如何识别基本数据类型的属性并处理空（nil，null）值的处理json中嵌套json（Dict或Array）的处理 尝试解决以上问题，你也能写出属于自己的功能完备的Json转Model库。 2、快速归档有时候我们要对一些信息进行归档，如用户信息类UserInfo，这将需要重写initWithCoder和encodeWithCoder方法，并对每个属性进行encode和decode操作。那么问题来了：当属性只有几个的时候可以轻松写完，如果有几十个属性呢？那不得写到天荒地老. 原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法： 123456789101112- (id)initWithCoder:(NSCoder *)aDecoder &#123; if (self = [super init]) &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; &#125; &#125; return self;&#125; 123456789- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125;&#125; 3、访问私有变量我们知道，OC中没有真正意义上的私有变量和方法，要让成员变量私有，要放在m文件中声明，不对外暴露。如果我们知道这个成员变量的名称，可以通过runtime获取成员变量，再通过getIvar来获取它的值。 方法： 12Ivar ivar = class_getInstanceVariable([Model class], &quot;_str1&quot;);NSString * str1 = object_getIvar(model, ivar);]]></content>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RAC+MVVM封装的网络请求]]></title>
    <url>%2FRAC-MVVM%E5%B0%81%E8%A3%85%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1.MVVM 代替 MVC 原因无论MVC还是MVVM，包括其他设计模式，核心目的是为了提高代码的简洁性，降低耦合度。简单点说就是让专门的人去做专门的事情。比如MVC模式中， M (model) V (view) C (controller) 但在MVC中，通过网络请求回来的数据会放到Model中，作为数据源来调用和处理。但还是存在控制器中文件很大的问题。很多业务逻辑都写到了控制器上了，不利于程序之间的解耦，而且在比较大的项目中，代码的可读性也比较差，而MVVM的引入大大减少了这个问题，会让C释放释放出来，关于视图方面的业务逻辑交给VM处理，C只用来解决控制器之间的连接问题。 2.RAC如何处理和传输数据那在RAC中怎么处理和传送数据呢？RAC最核心的内容是信号。我们可以把网络请求回来的数据通过信号传递和发送出去。我们把网络请求回来的数据叫做responseObject。基于RAC( 想深入探究 RAC 原理可点击史上最全ReactiveCocoa(RAC)之信号类源码解析)的知识，我们让订阅者发送数据，然后让信号接收数据，便完成数据的传递。同时RAC中有RACCommand的类，负责处理事件。所有总体可以分为三步： 网络请求，获得数据responseObject； 订阅者将responseObject发送出去； 信号订阅信号（接收发送处理的数据）。 3.代码实例至于代码层面是怎么解决这三个方面的问题呢? 我们假设一个使用场景：豆瓣上有开放的API，当我们查询图书的时候，当搜索”美女”关键词的时候，会出现很多关于美女的图书。然后将其显示在tableView上。 主要的业务逻辑包括： 通过AFN请求数据 将请求回来的数据传递给控制器 控制器的tableView完成数据的显示 3.1AFN请求数据12345AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager];[mgr GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:@&#123;@&quot;q&quot;:@&quot;美女&quot;&#125; success:^(AFHTTPRequestOperation * _Nonnull operation, NSDictionary * _Nonnull responseObject) &#123; NSLog(@&quot;发送成功&quot;); NSArray *dictArray = responseObject[@&quot;books&quot;]; [subscriber sendNext:dictArray]; 3.2请求回来的数据传给控制器在MVC中，通常会将请求回来的数据responseObject进行初步的处理，放到model模型中，然后tableView的数据源也来自于model，最终完成tableView的绘制和展示。 这里我们通过MVVM的方式，将网络请求的业务逻辑放到VM中处理。在V中实现tableView的数据源方法。 至于事件的处理就交给RAC来解决。RAC中有一个类RACCommond，来处理事件。 3.3具体代码处理的代码如下： 12345678910111213141516171819//通过RACCommand获取数据- (void)getData &#123; self.requestCommand = [[RACCommand alloc]initWithSignalBlock:^RACSignal *(id input) &#123; RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager]; [mgr GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:@&#123;@&quot;q&quot;:@&quot;美女&quot;&#125; success:^(AFHTTPRequestOperation * _Nonnull operation, NSDictionary * _Nonnull responseObject) &#123; NSLog(@&quot;发送成功&quot;); NSArray *dictArray = responseObject[@&quot;books&quot;]; [subscriber sendNext:dictArray]; &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123; NSLog(@&quot;发送失败&quot;); &#125;]; return nil; &#125;]; return signal; &#125;];&#125; 123456789//控制器接受传回来的数据- (void)getDataFromRequestVM &#123; RACSignal *signal = [self.requestVM.requestCommand execute:nil]; [signal subscribeNext:^(id x) &#123; self.dataArray = x; [self.tableView reloadData]; &#125;];&#125; 4.注意：为了避免外部修改，可以使用readOnly以上操作可以分步处理，也可以通过RACCommand的类来处理。 5.github地址demo下载地址]]></content>
      <tags>
        <tag>RAC MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RAC之常用方法汇总]]></title>
    <url>%2FRAC%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一、iOS内部对不同事件的处理iOS中对不同事件作出响应时，会用不同的方式来处理这些业务逻辑。比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO，通知等系统提供的方式。虽然说是对事件做出相应，但iOS内部需要用不同的方法，时常用起来非常的繁琐。其实这些事件，都可以通过RAC处理。 二、RAC的核心介绍RAC内部的核心类是RACSiganl。RACSiganl:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。 ReactiveCocoa为事件提供了很多处理方法，处理起来非常简单，而且代码放在一起，就不需要跳到对应的方法里。非常便于管理，也很符合我们开发中高聚合，低耦合的思想。 在介绍RAC底层时，我们已经对RAC的实现原理做了说明，本文会介绍RAC对不同事件的各种处理方式。 三、简单介绍不同的方法ReactiveCocoa开发中常见用法3.1 代替代理.rac_signalForSelector：用于替代代理。 3.2代替KVO :rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。 3.3 监听事件:rac_signalForControlEvents：用于监听某个事件。 3.4 代替通知:rac_addObserverForName:用于监听某个通知。 3.5 监听文本框文字改变:rac_textSignal:只要文本框发出改变就会发出这个信号。 3.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。 四、代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 // 1.代替代理 // 需求：自定义redView,监听红色view中按钮点击 // 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情 // rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。 // 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。 [[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123; NSLog(@&quot;点击红色按钮&quot;); &#125;]; // 2.KVO // 把监听redV的center属性改变转换成信号，只要值改变就会发送信号 // observer:可以传入nil [[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; // 3.监听事件 // 把按钮点击事件转换为信号，点击按钮，就会发送信号 [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; NSLog(@&quot;按钮被点击了&quot;); &#125;]; // 4.代替通知 // 把监听到的通知转换信号 [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;键盘弹出&quot;); &#125;]; // 5.监听文本框的文字改变 [_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@&quot;文字改变了%@&quot;,x); &#125;]; // 6.处理多个请求，都返回结果的时候，统一做处理. RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求1 [subscriber sendNext:@&quot;发送请求1&quot;]; return nil; &#125;]; RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求2 [subscriber sendNext:@&quot;发送请求2&quot;]; return nil; &#125;]; // 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。 [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];&#125;// 更新UI（该方法有要求，有多少个信号就要求有多少个参数，参数的内容就是发送的数据。）- (void)updateUIWithR1:(id)data r2:(id)data1&#123; NSLog(@&quot;更新UI%@,%@&quot;,data,data1);&#125; 文末：这里只是对RAC常用方法合集的简单描述和基础使用的介绍，至于RAC信号的原理，可以参考作者的《史上最全RAC之信号类源码解析》。至于RAC的bind(绑定)，map（映射），concat（组合）等高级用法，可参考作者的其它文章。]]></content>
      <tags>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RAC之masonry源码深度解析]]></title>
    <url>%2FRAC%E4%B9%8Bmasonry%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面：本文不是讲解masonry的基础使用，而是希望借着masonry的源码解析给大家渗透链式编程的思想和展示其具体实现。现在RAC（ReactiveCocoa）很火，借着这个成熟的案例让大家窥其一斑，作者在此抛砖引用，供大家交流参考。 一、NSLayoutConstraint约束实际iOS用NSLayoutConstraint对控件进行约束。比如：想要让子控件的顶部距离父控件顶部10pt，添加约束的实际条件就是满足subView.top = superView.top * 1 + 10这个公式就可以了。NSLayoutConstraint的实际就是对该公式的代码解释，代码如下: 12345678 NSLayoutConstraint *topConstraint = [NSLayoutConstraint constraintWithItem:subView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTop multiplier:1.0 constant:padding.top]; [self.view addConstraints:topConstraint]; 但我们需要对控件的top,bottom,left,right进行约束就特别麻烦。在OC中有一个库Masonry对NSLayoutConstraint进行了封装，**（Swift中使用SnapKit，SnapKit其实就是Masonry的Swift版本，实现思路大体一致。）** 二：masonry介绍masonry是iOS布局控件的轻量级框架。其原理是通过链式调用的方式对NSLayoutConstraint进行封装，简化了控件的约束方式。 抓住两头：其实massory最终还是利用苹果官方提供的NSLayoutConstraint，只是利用链式编程的方式进一步封装。 接下来思考两个问题 怎么通过封装？ 链式编程来实现约束的添加的？ 接下来我们就对masonry的封装做进一步解释。 1.masonry添加约束的代码实现123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; UIView *subView = [[UIView alloc]init]; subView.backgroundColor = [UIColor purpleColor]; //先添加控制，后设置约束，不然找不到约束的依赖，会报错。 [self.view addSubview:subView]; [subView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.top.equalTo(@20); make.right.bottom.equalTo(@-10); &#125;];&#125; 2.masonry方法执行步骤解析： 子控件调用mas_makeConstraints方法，mas_makeConstraints方法有个block参数（返回值为void,参数为MASContraintMaker的实例对象make）； block作为方法的参数就是隐式调用（block并没有真正调用，需要在方法内部，block()调用一次，才会真正执行block）； block的有一个MASContraintMaker类的实例make作为参数，让make去添加约束； MASContraintMaker类中有个可变数组的属性，用于保存约束； 执行mas_makeConstraints传入进行的block； 遍历数组中的约束，完成约束的安装； 以上只是文字描述了执行的大致步骤，具体的代码实现是怎么样的呢？我们接下里通过三个问题来展开。 3.疑问123&gt; 1. make的点语法代表什么意思？&gt; 2. 为什么可以连续用点语法？&gt; 3. 具体代码解析是什么样的？ 问题一：make的点语法代表什么意思？make.left.top.equalTo(@20); 实质就是MASContraintMaker类的实例对象make调用了属性的getterter方法。扒开源码我们会看到 1234567@interface MASConstraintMaker : NSObject@property (nonatomic, strong, readonly) MASConstraint *left;@property (nonatomic, strong, readonly) MASConstraint *top;//省略了bottom,right，baseline等属性。@end 1234567891011121314151617181920212223242526272829//getter方法，返回的是MASConstraint对象，getter方法调用 addConstraintWithLayoutAttribute:- (MASConstraint *)left &#123; return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];&#125;//返回的是MASConstraint对象，接着调用constraint: addConstraintWithLayoutAttribute:方法- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];&#125;- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; if (!constraint) &#123; newConstraint.delegate = self; // [self.constraints addObject:newConstraint]; &#125; return newConstraint;&#125; 问题二：为什么可以连续用点语法？ 链式编程的核心：每个点语法实际调用的getter方法，getter方法的返回值为实例对象本身，然后继续调用getter方法，就成为链式了。结合代码进行具体解释：make.left.top.equalTo(@10);我们对其分开解释：点语法返回的时一个新的约束newConstraint。 12345`make.left.top.equalTo(@10);`//分开写就为newConstraint1 = make.left;newConstraint2 = newConstraint1.top;newConstraint2.equalTo(@10); 12345- (MASConstraint * (^)(id))equalTo &#123; return ^id(id attribute) &#123; return self.equalToWithRelation(attribute, NSLayoutRelationEqual); &#125;;&#125; 问题三：整个方法的具体调用步骤是什么样的？首先解释下MASConstraintMaker类： MASConstraintMaker类就是一个工厂类，负责创建MASConstraint类型的对象（依赖于MASConstraint接口，而不依赖于具体实现） 粗略步骤： UIView的类调用mas_makeConstraints方法 mas_makeConstraints有个block参数，会做隐式回调 获得约束数组，通过install安装约束。 1.mas_makeConstraints方法解析用户是UIView调用扩展的UIView+MASAdditions分类的mas_makeConstraints方法来为当前视图添加约束的。mas_makeConstraints方法的返回值是一个数组（NSArray）,数组中所存放的就是当前视图中所添加的所有约束。因为Masonry框架对NSLayoutConstraint封装成了MASViewConstraint，所有此处数组中存储的是MASViewConstraint对象。 接下来来看mas_makeConstraints的参数，mas_makeConstraints测参数是一个类型为void(^)(MASConstraintMaker *)的匿名block（也就是匿名闭包），该闭包的返回值为void, 并且需要一个MASConstraintMaker工厂类的一个对象。该闭包的作用就是可以让mas_makeConstraints方法通过该block给MASConstraintMaker工厂类对象中的MAConstraint属性进行初始化。具体可以参考下面的代码及其注释: 1234567891011//新建并添加约束- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123; //关闭自动添加约束，由我们手动添加约束 self.translatesAutoresizingMaskIntoConstraints = NO; //实例化constraintMaker对象，来操作接下来的约束 MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; //block作为参数，这里完成隐式调用，完成回调，通过block将constraintMaker对象回调给用户让用户对constraintMaker中的MAConstraint类型的属性进行初始化。换句话说block中所做的事情就是之前用户设置约束是所添加的代码，比如make.top(@10) == ( constraintMaker.top = 10 )。 block(constraintMaker); //添加约束，但会Install的约束数组 return [constraintMaker install];&#125; 2. block参数的隐式回调返回的值为一个block,block的返回值是MASConstraint类的实例对象，所以最终还是返回的MASConstraint类的实例对象。12345- (MASConstraint * (^)(id))equalTo &#123; return ^id(id attribute) &#123; return self.equalToWithRelation(attribute, NSLayoutRelationEqual); &#125;;&#125; 3.约束安装install方法实际的过程是： 判断是否有约束，有就遍历约束，调用uninstall清空之前所有的约束 无约束，就遍历数组的约束对象，然后调用install逐个安装 调用系统的方法安装约束 1234567891011121314151617- (NSArray *)install &#123; //判断是否存在约束，存在就遍历所有约束，然后移除 if (self.removeExisting) &#123; NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view]; for (MASConstraint *constraint in installedConstraints) &#123; [constraint uninstall]; &#125; &#125; //不存在约束，就复制约束，然后遍历数组中的约束，完成安装。 NSArray *constraints = self.constraints.copy; for (MASConstraint *constraint in constraints) &#123; constraint.updateExisting = self.updateExisting; [constraint install]; &#125; [self.constraints removeAllObjects]; return constraints;&#125; 文末：以上是masonry。通过这个也是给大家渗透链式编程的思想。可能很多人对block作为返回值比较难理解，但这是整个链式编程的核心。]]></content>
  </entry>
  <entry>
    <title><![CDATA[史上最全ReactiveCocoa(RAC)之信号类源码解析]]></title>
    <url>%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8ReactiveCocoa-RAC-%E4%B9%8B%E4%BF%A1%E5%8F%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[信号signal是RAC的绝对核心，所有的操作都是围绕着信号来处理的。比如：创建信号，订阅信号，发送信号是消息发送的核心步骤。常见的三个信号类为： RACSignal RACSubject RACReplaySubject 一、RACSignal代码实现：1234567891011121314// 1.创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 注：block在此仅仅是个参数，未被调用， //当有订阅者订阅信号时会调用block。// 2.发送信号 [subscriber sendNext:@1]; // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 return nil; &#125;];// 3.订阅信号,才会激活信号. [siganl subscribeNext:^(id x) &#123; // block调用时刻：每当有信号发出数据，就会调用block. NSLog(@&quot;接收到数据:%@&quot;,x); &#125;]; 使用步骤：1.创建信号1+(RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe; 12345678910111213内部原理：* 1.1 方法解析：方法名为createSignal：其返回值类型为RACSignal类的实例变量。参数为一个名字为didSubscribe的block。* 1.2 方法参数didSubscribe解析：(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;&#125;的返回值是RACDisposable类型的实例变量，参数为id类型且遵守且遵守RACSubscriber协议的subscriber。* 1.3 创建信号，首先把didSubscribe这个block保存到信号中，但不会触发。此时didSubscribe仅仅作为方法的参数，并没有被触发，所以信号也仅仅是一个冷信号，block内部不会执行。（具体执行见下文）源码解析：+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;//创建了一个RACDynamicSignal类的信号RACDynamicSignal *signal = [[self alloc] init];//将代码块保存到信号里面（但此时仅仅是保存，没有调用）signal-&gt;_didSubscribe = [didSubscribe copy];return [signal setNameWithFormat:@&quot;+createSignal:&quot;];&#125; 2.订阅信号 （激活信号，冷信号编程热信号） (RACDisposable *)subscribeNext:(void (^ )(id x))nextBlock； 1234567891011121314151617181920212223242526272829303132333435363738* 2.1当信号被订阅，也就是调用signal的subscribeNext:nextBlock，* 2.2nextBlock内部创建了订阅者subscriber，并且把nextBlock保存到subscriber中。// RACSignal.h- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;NSCParameterAssert(nextBlock != NULL); //内部创建了RACSubscriber（订阅者）类的实例对象o，并且将nextBlock保存到o中，在返回值出执行o,实际也是执行了nextBlock。RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];return [self subscribe:o]; //内部执行了nextBlock，具体见下文&#125;+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123; RACSubscriber *subscriber = [[self alloc] init];//将block保存到subscriber中 subscriber-&gt;_next = [next copy]; subscriber-&gt;_error = [error copy]; subscriber-&gt;_completed = [completed copy]; return subscriber;&#125;//执行- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];//判断有无self.didSubscribe,有则执行该self.didSubscribe，意味着将订阅者subscriber发送过去 if (self.didSubscribe != NULL) &#123; RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; &#125;]; [disposable addDisposable:schedulingDisposable]; &#125; return disposable;&#125; 3.发送信号 订阅信号时，将subscriber传递给didSubscribe的参数subscriber 利用[subscriber sendNext:@1]方法发送信号。 1234567891011121314// RACSubscriber.h// These callbacks should only be accessed while synchronized on self.@property (nonatomic, copy) void (^next)(id value);//名为next的block是返回值为void，参数为id类型的value，在sendNext:内部，将next复制给nextBlock，执行该方法后，subscribeNext:的block参数才会被调用。- (void)sendNext:(id)value &#123; @synchronized (self) &#123; void (^nextBlock)(id) = [self.next copy]; if (nextBlock == nil) return; //执行nextBlock，发送value nextBlock(value); &#125;&#125; RACSignal原理流程图： RACSignal总结：三步骤（先创建信号，然后订阅信号，最后执行didSubscribe内部的方法）顺序是不能变的。&gt; RACSignal底层实现： * 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 * 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 2.2 subscribeNext内部会调用siganl的didSubscribe * 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; * 3.1 sendNext底层其实就是执行subscriber的nextBlock 二、RACSubject RACSubject:信号提供者，自己可以充当信号，又能发送信号。 先来简单回顾下，RACSignal类中发送和订阅信号是两步完成的。 1234//发送信号的为遵守RACSubscribe协议的对象subscriber完成发送[subscriber sendNext:@1];//订阅信号的为RACSignal的实例对象[siganl subscribeNext:^(id x) &#123;&#125;； 疑问：有没有办法让一个对象既能发送也可以发送消息呢？ 其实很简单，只要让具有RACSignal对象遵守RACSubscribe协议，就既能发送，又能订阅信号了。这个类就是RACSubject。虽然和RACSignal一样都具有订阅和发送信号的能力，但其内部原理不同。下文是对RACSubject类进行剖析。 代码实现 调用顺序不变，但是可以创建多个订阅者，并发送信号； 1234567891011121314151617 // 1.创建信号 RACSubject *subject = [RACSubject subject]; // 2.订阅信号（这里可以创建多个订阅者） [subject subscribeNext:^(id x) &#123; // block调用时刻：当信号发出新值，就会调用. NSLog(@&quot;第一个订阅者%@&quot;,x); &#125;]; [subject subscribeNext:^(id x) &#123; // block调用时刻：当信号发出新值，就会调用. NSLog(@&quot;第二个订阅者%@&quot;,x); &#125;]; [subject subscribeNext:^(id x) &#123; // block调用时刻：当信号发出新值，就会调用. NSLog(@&quot;第三个订阅者%@&quot;,x); &#125;];// 3.发送信号 [subject sendNext:@&quot;1&quot;]; 源码解析1.创建信号123456789101112131415// RACSubject.m+ (instancetype)subject &#123; return [[self alloc] init];&#125;- (id)init &#123; self = [super init]; if (self == nil) return nil; _disposable = [RACCompoundDisposable compoundDisposable]; _subscribers = [[NSMutableArray alloc] initWithCapacity:1]; return self;&#125; 2.订阅信号 不同类型的信号，创建订阅者的方式不同，RACSignal订阅信号时，调用了形影的block。 而RACSubject订阅信号的实质就是将内部创建的订阅者保存在订阅者数组self.subscribers中，仅此而已。订阅者对象有一个名为nextBlock的block参数。 12345678910111213141516171819202122232425262728293031- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123; NSCParameterAssert(nextBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o];&#125;- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; NSMutableArray *subscribers = self.subscribers; @synchronized (subscribers) &#123; //将订阅者保存在订阅者数组中 [subscribers addObject:subscriber]; &#125; return [RACDisposable disposableWithBlock:^&#123; @synchronized (subscribers) &#123; // Since newer subscribers are generally shorter-lived, search // starting from the end of the list. NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123; return obj == subscriber; &#125;]; if (index != NSNotFound) [subscribers removeObjectAtIndex:index]; &#125; &#125;];&#125; 3.发送信号 底层实现是： 先遍历订阅者数组中的订阅者; 后执行订阅者中的nextBlock; 最后让订阅者发送信号。 12345678910111213141516171819202122// RACSubject.m- (void)sendNext:(id)value &#123;//顺序A：遍历保存在数组中的订阅者对象 [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;//顺序E：调用订阅者，执行sendNext:方法 [subscriber sendNext:value]; &#125;];&#125;//顺序B:遍历subscribers数组中的订阅者对象，执行block。- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block &#123; NSArray *subscribers; @synchronized (self.subscribers) &#123; subscribers = [self.subscribers copy]; &#125;//顺序C:遍历数组，取出subscriber的block，并且执行。 for (id&lt;RACSubscriber&gt; subscriber in subscribers) &#123;//顺序D,执行block block(subscriber); &#125;&#125; RACSubject原理流程图： 总结123RACSubscriber:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。RACDisposable:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 RACSubject:底层实现和RACSignal不一样。 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 3.由于本质是将订阅者保存到数组中，所以可以有多个订阅者订阅信息。 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。RACSubject:信号提供者，自己可以充当信号，又能发送信号。 使用场景:通常用来代替代理，有了它，就不必要定义代理了。 缺点：还是必须先订阅，后发送信息。订阅信号就是创建订阅者的过程，如果不先订阅，数组中就没有订阅者对象，那就通过订阅者发送消息。 三、RACReplaySubject介绍上文中提到了，RACSubject要求先订阅，后发送信号。##**代码实现：** 1234567891011121314// 1.创建信号 RACReplaySubject *subject = [RACReplaySubject subject];// 2.订阅信号 [subject subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; // 遍历所有的值,拿到当前订阅者去发送数据// 3.发送信号 [subject sendNext:@1]; // RACReplaySubject发送数据: // 1.保存值 // 2.遍历所有的订阅者,发送数据 // RACReplaySubject:可以先发送信号,在订阅信号 使用步骤：1.创建信号1234567891011121314151617181920// RACReplaySubject.m+ (instancetype)subject &#123; return [[self alloc] init];&#125;- (instancetype)init &#123; return [self initWithCapacity:RACReplaySubjectUnlimitedCapacity];&#125;//此时调用的子类RACReplaySubject的初始化方法- (instancetype)initWithCapacity:(NSUInteger)capacity &#123; self = [super init]; if (self == nil) return nil; _capacity = capacity;//会用_valuesReceived这个数组保存值value _valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]); return self;&#125; 2.订阅信号 遍历拿到保存在数组中的所有值，然后调用subscriber发送信号。 12345678910111213141516171819202122232425262728293031323334353637- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123; NSCParameterAssert(nextBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o]; //创建订阅者的方式不同&#125;//RACReplaySubject类对象执行[self subscribe:o]- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable]; RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; @synchronized (self) &#123;//先遍历self.valuesReceived的所有的值，后让subscriber调用sendNext:发送信号。 for (id value in self.valuesReceived) &#123; if (compoundDisposable.disposed) return; [subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)]; &#125; if (compoundDisposable.disposed) return; if (self.hasCompleted) &#123; [subscriber sendCompleted]; &#125; else if (self.hasError) &#123; [subscriber sendError:self.error]; &#125; else &#123; RACDisposable *subscriptionDisposable = [super subscribe:subscriber]; [compoundDisposable addDisposable:subscriptionDisposable]; &#125; &#125; &#125;]; [compoundDisposable addDisposable:schedulingDisposable]; return compoundDisposable;&#125; 3.发送信号123456789101112- (void)sendNext:(id)value &#123; @synchronized (self) &#123;//重点：发送信号的时候，会先将值value保存到数组中， [self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];//调用父类发送（先遍历订阅者，然后发送值value） [super sendNext:value]; if (self.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; self.valuesReceived.count &gt; self.capacity) &#123; [self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)]; &#125; &#125;&#125; RACReplaySubject原理图 RACReplaySubject总结RACReplaySubject是RACSubject的子类。 RACReplaySubject使用步骤: 12345// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。// 2.可以先订阅信号，也可以先发送信号。 // 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock // 2.2 发送信号 sendNe]]></content>
      <tags>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣谈iOS运行时之方法调用原理]]></title>
    <url>%2F%E8%B6%A3%E8%B0%88iOS%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[导语一个成熟的计算机语言必然有丰富的体系，复杂的容错机制，处理逻辑以及判断逻辑。但这些复杂的逻辑都是围绕一个主线丰富和展开的，所以在学习计算机语言的时候，先掌握核心，然后了解其原理，明白程序语言设计的实质和当时选择这种处理方式的原因是极其必要的，而且也是学习语言的捷径。 所以在学习的过程中，需要把握几个核心 先专注主线，后丰富周边；先宏观了解，后微观精通;多设身处地思考，理解代码设计的原因;理解代码设计的原理和优化 OC中处理方法的业务逻辑和其他语言不同，OC语言是动态语言（动态绑定，动态加载(dynamatic binding),动态类型）。其中动态加载就涉及到OC的运行时。在OC中，方法是动态实现的，调用方法实际就是在发送消息。试想一下，一个方法的实现必然包含三个部分： 1.执行方法的对象2.方法名称3.不确定的参数 SEL只是一个方法名称，IMP才是执行方法最终的函数。IMP 是一个函数指针,包含一个接收消息的对象 id(self 指针), 调用方法的选标 SEL (方法名),以及不定个数的参数,并返回一个 id。也就是说 IMP 是消息最终调用的执行代码,是方法真正的实现代码 。 提问时间到了： 动态和静态有什么区别？ 执行方法是怎么实现的？ OC的方法和C语言的函数原理一样么？ 动态和静态有区别的；首先我们从最表层理解，一个方法的实现必然要包含执行者，方法名和不确定的参数和返回值。无论是静态或者动态方法都必须这三个必要元素(动态和静态的区别就在于在何时确定这些必要元素)。方法的执行包含编译和运行两个过程。 静态方法是在编译时已经确定了三个要素，且不能更改。若类型不对，就会直接发出警告。 而OC的动态方法可以直接跳过编译，在运行时才开始添加函数调用，决定执行方法的三个要素。这就是动态方法（至于怎么执行，下面开始讲解） 这三个元素是如何确定的呢？首先我们看一段示例代码 12Dog *aDog = [[Dog alloc]init];[aDog run]; 在执行方法时，是怎么确定的呢？此时我们需要注意OC内部方法的实质：OC中，方法实现实质就是发送消息。[aDog run];代码的实质就是[ objc_sendMsg]，它会找到执行方法的三个要素，找到就按照规则执行。发送消息是通过 objc_send(id, SEL, ...) 来实现的,它首先会在对象的类对象的 cache，methodlist 以及父类对象的 cache,methodlist 中依次查找 SEL 对应 的 IMP;如果没有找到且实现了动态方法决议机制就会进行决议。 如果没有实现动态方法决议机制或决议失败且实现了消息转发机制就会进入消息转发流程,否则程序 crash。也就是说如果同时提供了动态方法决议和消息转发,那么动态方法决议先于消息转发,只有当动态方法决议依然无法正确决议 selector 的 实现,才会尝试进行消息转发。当然，实际过程不可能那么简单，在开发语言之初，肯定会完善各种复杂场景和做了很多优化，接下来我们一起研究下OC对方法执行和扩展和优化： 第一步：先找方法 第二步：动态方法决议 第三部：消息转发 最后： 报错 消息转发通常,给一个对象发送它不能处理的消息会得到出错提示,然而,Objective-C运行时系统在抛出错误之前, 会给消息接收对象发送一条特别的消息 forwardInvocation 来通该对象,该消息的唯一参数是个 NSInvocation 类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现 forwardInvocation:方法来对不能处理的消息做一些默认的处理,也可以将消息转发给其他对 象来处理,而不抛出错误。 1,首先去该类的方法cache中查找,如果找到了就返回它; 2,如果没有找到,就去该类的方法列表中查找。如果在该类的方法列表中找到了,则将 IMP 返回,并将 它加入 cache 中缓存起来。根据最近使用原则,这个方法再次调用的可能性很大,缓存起来可以节省下次 调用再次查找的开销。 3,如果在该类的方法列表中没找到对应的IMP,在通过该类结构中的super_class指针在其父类结构的方法列表中去查找,直到在某个父类的方法列表中找到对应的IMP,返回它,并加入cache中; 4,如果在自身以及所有父类的方法列表中都没有找到对应的 IMP,则看是不是可以进行动态方法决议(后 面有专文讲述这个话题); 5,如果动态方法决议没能解决问题,进入下面要讲的消息转发流程。便利函数:我们可以通过 NSObject 的一些方法获取运行时信息或动态执行一些消息: class 返回对象的类:12345isKindOfClass,isMemberOfClass 检查对象是否在指定的类继承体系中;respondsToSelector 检查对象能否相应指定的消息;conformsToProtocol 检查对象是否实现了指定协议类的方法;methodForSelector 返回指定方法实现的地址；performSelector:withObject 执行 SEL 所指代的方法 OC做为一门面向对象语言，自然具有面向对象的语言特性，如封装、继承、多态。他具有静态语言的特性(如C++)，又有动态语言的效率(动态绑定、动态加载等)。整体来说，确实是一门不错的编程语言。 OC的动态语言特性现在，让我来想想OC的动态语言特性。OC的动态特性表现为了三个方面：动态类型、动态绑定、动态加载。之所以叫做动态，是因为必须到运行时(runtime)才会做一些事情。 （1）动态类型动态类型，说简单点就是id类型。动态类型是跟静态类型相对的。像内置的明确的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(runtime)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。 （2）动态绑定动态绑定(dynamic binding)貌似比较难记忆，但事实上很简单，只需记住关键词@selector/SEL即可。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去。这就是动态绑定，要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。这里要注意一点：SEL并不是C里面的函数指针，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。 （3）动态加载动态加载就是根据需求动态地加载资源。我对动态加载比较陌生，所以就没什么可总结的啦。等以后慢慢完善。 写在最后技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。]]></content>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员变量和属性的前世今生]]></title>
    <url>%2F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%2F</url>
    <content type="text"><![CDATA[目录：1.简述编译器的变化对@property的影响；2.实际使用中@property和成员变量+ @property + @synthesize 成员变量的区别3.self.XXX,_XXX,self-&gt;XXX的区别；4.Demo地址 历史由来：接触iOS的人都知道，@property声明的属性默认会生成一个_类型的成员变量，同时也会生成setter/getter方法。但这只是在iOS5之后，苹果推出的一个新机制。看老代码时，经常看到一个大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用@synthesize方法。如下： 12345678910111213@interface ViewController ()&#123; // 1.声明成员变量 NSString *myString; &#125; //2.在用@property@property(nonatomic, copy) NSString *myString; @end@implementation ViewController//3.最后在@implementation中用synthesize生成set方法@synthesize myString; @end 其实，发生这种状况根本原因是苹果将默认编译器从GCC转换为LLVM(low level virtual machine)，才不再需要为属性声明实例变量了。 在没有更改之前，属性的正常写法需要成员变量+ @property + @synthesize 成员变量三个步骤。如果我们只写成员变量+ @property 123456@interface GBViewController :UIViewController&#123; NSString *myString;&#125;@property (nonatomic, strong) NSString *myString;@end 编译时会报警告:property 'myString' will use synthesized instance variable '_myString', not existing instance variable 'myString''```123456789但更换为LLVM之后，编译器在编译过程中发现没有新的实例变量后，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量。（**注意：是不必要，不是不可以**）当然我们也熟知，`@property`声明的属性不仅仅默认给我们生成一个_类型的成员变量，同时也会生成`setter/getter`方法。在`.m`文件中，编译器也会自动的生成一个实例变量`_XXX`。那么在.m文件中可以直接的使用`_XXX`实例变量，也可以通过属性`self. XXX`。只是我们需要注意这里的`self.XXX`实际是调用`XXX`属性的`setter/getter`方法。这与C++中点的使用是有区别的，C++中的点可以直接访问成员变量(也就是实例变量)。**例如在OC中有如下代码** @interface MyViewController :UIViewController{ NSString *name;}@end`` 在这段代码里面只是声明了一个成员变量，并没有setter/getter方法。所以访问成员变量时，可以直接访问name，也可以像C++一样用self-&gt;name来访问，但绝对不能用self.name`来访问。 扩展:很多人觉得OC中的点语法比较奇怪，实际是OC设计人员有意为之。 点表达式(.)看起来与C语言中的结构体访问以及java语言汇总的对象访问有点类似，如果点表达式出现在等号 ＝ 左边，调用该属性名称的setter方法。如果点表达式出现在＝右边，调用该属性名称的getter方法。 OC中点表达式(.)其实就是调用对象的setter和getter方法的一种快捷方式，self.myString = @&quot;张三&quot;;实际就是[self setmyString:@&quot;张三&quot;]; 首先我们要明白，@synthesize 生成了setter/getter方法。虽然现在直接使用@property时，编译器会自动为你生成以下划线开头的实例变量_myString，不需要自己手动再去写实例变量。而且也不在.m文件中通过@synthesize myString；生成setter/getter方法。但在看老代码的时候，我们依旧可以看到有人使用成员变量+ @synthesize 成员变量的形式。 那么问题来了：我们能否认为新编译器LLVM下的@property == 老编译器GCC的 成员变量+ @property + @synthesize 成员变量呢？ 答案是否定的，因为成员变量+ @property + @synthesize 成员变量的形式，编译器不会帮我们生成_成员变量，因此不会操作_成员变量了；同时@synthesize 还有一个作用，可以指定与属性对应的实例变量，例如@synthesize myString = xxx；那么self.myString其实是操作的实例变量xxx，而非_String了。 在Demo中会有非常详细的说明，欢迎下载和start。 写在最后技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。]]></content>
      <tags>
        <tag>成员变量 属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[category和extension史上最全攻略]]></title>
    <url>%2Fcategory%E5%92%8Cextension%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[背景：在大型项目，企业级开发中多人同时维护同一个类，此时程序员A因为某项需求只想给当前类currentClass添加一个方法newMethod，那该怎么办呢？最简单粗暴的方式是把newMethod添加到currentClass中，然后直接实现该方法就OK了。但考虑到OC是单继承的，子类可以拥有父类的方法和属性。如果把newMethod写到currentClass中，那么currentClass的子类也会拥有newMethod。但真正的需求是只需要currentClass拥有newMethod，而currentClass的子类不会拥有。苹果为了解决这个问题，就引入了分类（Category）的概念。 分类（Category）：概念分类（Category）是OC中的特有语法，它是表示一个指向分类的结构体的指针。原则上它只能增加方法，不能增加成员（实例）变量。具体原因看源码组成: Category源码：12345678910CategoryCategory 是表示一个指向分类的结构体的指针，其定义如下：typedef struct objc_category *Category;struct objc_category &#123; char *category_name OBJC2_UNAVAILABLE; // 分类名 char *class_name OBJC2_UNAVAILABLE; // 分类所属的类名 struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表 struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 分类所实现的协议列表&#125; 123456通过上面我们可以发现，这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods 列表是 objc_class 中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。但这个结构体里面根本没有属性列表，根本没有属性列表，根本没有属性列表。 注意：1.分类是用于给原有类添加方法的,因为分类的结构体指针中，没有属性列表，只有方法列表。所以&lt; 原则上讲它只能添加方法, 不能添加属性(成员变量),实际上可以通过其它方式添加属性&gt; ;2.分类中的可以写@property, 但不会生成setter/getter方法, 也不会生成实现以及私有的成员变量（编译时会报警告）;3.可以在分类中访问原有类中.h中的属性;4.如果分类中有和原有类同名的方法, 会优先调用分类中的方法, 就是说会忽略原有类的方法。所以同名方法调用的优先级为 分类 &gt; 本类 &gt; 父类。因此在开发中尽量不要覆盖原有类;5.如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定；编译器会执行最后一个参与编译的分类中的方法。 分类格式：12345@interface 待扩展的类（分类的名称）@end@implementation 待扩展的名称（分类的名称）@end 实际代码如下：123456789101112// Programmer+Category.h文件中@interface Programmer (Category)@property(nonatomic,copy) NSString *nameWithSetterGetter; //设置setter/getter方法的属性@property(nonatomic,copy) NSString *nameWithoutSetterGetter; //不设置setter/getter方法的属性（注意是可以写在这，而且编译只会报警告，运行不报错）- (void) programCategoryMethod; //分类方法@end// Programmer+Category.m文件中 那么问题来了： 为什么在分类中声明属性时，运行不会出错呢？既然分类不让添加属性，那为什么我写了@property仍然还以编译通过呢？ 接下来我们探究下分类不能添加属性的实质原因： 我们知道在一个类中用@property声明属性，编译器会自动帮我们生成_成员变量和setter/getter，但分类的指针结构体中，根本没有属性列表。所以在分类中用@property声明属性，既无法生成_成员变量也无法生成setter/getter。因此结论是：我们可以用@property声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。但如果调用了_成员变量和setter/getter方法，报错就在所难免了。 报错原因如下 123456//普通声明，无setter/getter// programmer.nameWithoutSetterGetter = @&quot;无setter/getter&quot;; //调用setter，编译成功，运行报错为：（-[Programmer setNameWithSetterGetter:]: unrecognized selector sent to instance 0x7f9de358fd70&apos;） // NSLog(@&quot;%@&quot;,programmer.nameWithoutSetterGetter); //调用getter，编译成功，运行报错为-[Programmer setNameWithSetterGetter:]: unrecognized selector sent to instance 0x7fe22be11ea0&apos;// NSLog(@&quot;%@&quot;,_nameWithoutSetterGetter); //这是调用_成员变量,错误提示为：（Use of undeclared identifier &apos;_nameWithoutSetterGetter&apos;） 那接下来我们继续思考:既然报错的根本原因是使用了系统没有生成的setter/getter方法，可不可以在手动添加setter/getter来避免崩溃，完成调用呢？其实是可以的。由于OC是动态语言，方法真正的实现是通过runtime完成的，虽然系统不给我们生成setter/getter，但我们可以通过runtime手动添加setter/getter方法。那具体怎么实现呢？ 代码实现如下:按照这个思路，我们通过运行时手动添加这个方法。 12345678910111213141516#import &lt;objc/runtime.h&gt;static NSString *nameWithSetterGetterKey = @&quot;nameWithSetterGetterKey&quot;; //定义一个key值@implementation Programmer (Category)//运行时实现setter方法- (void)setNameWithSetterGetter:(NSString *)nameWithSetterGetter &#123; objc_setAssociatedObject(self, &amp;nameWithSetterGetterKey, nameWithSetterGetter, OBJC_ASSOCIATION_COPY);&#125;//运行时实现getter方法- (NSString *)nameWithSetterGetter &#123; return objc_getAssociatedObject(self, &amp;nameWithSetterGetterKey);&#125;@end 实际使用效果1234//通过runtime实现了setter/getter programmer.nameWithSetterGetter = @&quot;有setter/getter&quot;; //调用setter，成功 NSLog(@&quot;%@&quot;,programmer.nameWithSetterGetter); //调用getter，成功// NSLog(@&quot;%@&quot;,_nameWithSetterGetter); //这是调用_成员变量，错误提示为：（Use of undeclared identifier &apos;_nameWithSetterGetter&apos;） 问题解决。 但是注意，以上代码仅仅是手动实现了setter/getter方法，但调用_成员变量依然报错。 类扩展（Class Extension）Extension是Category的一个特例。类扩展与分类相比只少了分类的名称，所以称之为“匿名分类”。其实开发当中，我们几乎天天在使用。对于有些人来说像是最熟悉的陌生人。 类扩展格式：1234@interface XXX ()//私有属性//私有方法（如果不实现，编译时会报警,Method definition for &apos;XXX&apos; not found）@end 作用： 为一个类添加额外的原来没有变量，方法和属性一般的类扩展写到.m文件中一般的私有属性写到.m文件中的类扩展中 类别与类扩展的区别： ①类别中原则上只能增加方法（能添加属性的的原因只是通过runtime解决无setter/getter的问题而已）；②类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（用范围只能在自身类，而不是子类或其他地方）；③类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。④类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。⑤定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。 点击下载Demo最后总结：关于分类，类扩展等问题，在很多概念性的东西网上讲解的很是模糊，而且在实际应用的背后的原理上也少有展开。作者写这篇文章的目的就是想让读者对分类，类扩展等常见的问题有个清晰的认识，免了看了记不住，记住又记不对，记对了又不明白原因。在实际开发中，很多工具类都是分类，类扩展的实际应用，所以笔者后续会在我的个人GitHub上放出工具类，欢迎start和follow。文章是本人通过实际代码和自己的开发经验整理而成，如果你喜欢我的文章，欢迎喜欢和打赏。技术的进步成长需要交流碰撞，也期待你的留言评论，不要只做一个MARK党。]]></content>
      <tags>
        <tag>category</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入runtime探究KVO]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5runtime%E6%8E%A2%E7%A9%B6KVO%2F</url>
    <content type="text"><![CDATA[前言Objective-C 中的键(key)-值(value)观察(KVO)并不是什么新鲜事物,它来源于设计模式中的观察者模式,其基本思想就是: 一个目标对象管理所有依赖于它的观察者对象,并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。 在 Objective-C 中有两种使用键值观察的方式:手动或自动,此外还支持注册依赖键(即一个键依赖于 其他键,其他键的变化也会作用到该键)。下面将一一讲述这些,并会深入 Objective-C 内部一窥键值 观察是如何实现的。 观察者（Observer） 观察者（Observer）定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。在 Cocoa Touch 框架中通知和 KVO 都实现了观察者模式。通知是由一个中心对象为所有观察者提供变更通知，KVO 是被观察的对象直接向观察者发送通知。如上图，Subject 的值改变时，通知观察者 ObserverA，ObserverB，ObserverC，我的数据改变了，依赖我的你们需要更新状态了。被观察者不需要知道有多少个观察者和观察者的更新细节，降低被观察者和观察者之间的耦合。 运用键值观察1,注册与解除注册如果我们已经有了包含可供键值观察属性的类,那么就可以通过在该类的对象(被观察对象)上调用名 为 NSKeyValueObserverRegistration 的 category 方法将观察者对象与被观察者对象注册与解除 注册: 12- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath opt ions:(NSKeyValueObservingOptions)options context:(void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 这两个方法的定义在 Foundation/NSKeyValueObserving.h 中,NSObject,NSArray,NSSet 均实现了以上方法,因此我们不仅可以观察普通对象,还可以观察数组或结合类对象。在该头文件中,我们还 可以看到 NSObject 还实现了 NSKeyValueObserverNotification 的 category 方法(更多类似方 法,请查看该头文件): 12- (void)willChangeValueForKey:(NSString *)key;- (void)didChangeValueForKey:(NSString *)key; 注意：不要忘记解除注册,否则会导致资源泄露。 2,设置属性将观察者与被观察者注册好之后,就可以对观察者对象的属性进行操作,这些变更操作就会被通知给观察 者对象。注意,只有遵循 KVO 方式来设置属性,观察者对象才会获取通知,也就是说遵循使用属性的 setter 方法,或通过 key-path 来设置: 1234//必须是set方法target.age = 30;[target setAge:30];[target setValue:[NSNumber numberWithInt:30] forKey:@&quot;age&quot;]; 3,处理变更通知观察者需要实现名为 NSKeyValueObserving 的 category 方法来处理收到的变更通知: 1- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context; 注意：在这里change 这个字典保存了变更信息,具体是哪些信息取决于注册时 的 NSKeyValueObservingOptions。 KVO的内部实现原理：KVO是基于runtime机制实现的，当某个类的属性对象第一次被观察时，系统就会在运行期间动态地创建该类的一个派生类，在这个派生类中重写基类的任何被观察属性的setter方法。派生类在被重写的setter方法内实现真正的通知机制如果原类为Person，那么生成的派生类名为NSKVONotifying_Person。 我们知道，每一个类中都有一个isa指针指向当前类，所有系统就是在当一个类的对象第一次被观察的时候，系统就会偷偷将isa指针指向动态生成的派生类，从而在被监听属性赋值时被执行的是派生类的setter方法键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:;在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey: ofObject: change: context: 也会被调用。 补充：KVO的这套实现机制中苹果还偷偷重写了class方法以“欺骗”外部调用者，让我们误认为还是使用的当前类，然后系统将这个对象的 isa 指针指向这个新诞生的派生类,因此这个对象就成为该派生类的对象了,因而在该对象上对 setter 的调 用就会调用重写的 setter,从而激活键值通知机制。此外,派生类还重写了 dealloc 方法来释放资源。 写在最后技术学习绝不能孤胆英雄独闯天涯，而应在一群人的交流碰撞，享受智慧火花的狂欢。希望我的文章能成为你的盛宴，也渴望你的建议能成为我的大餐。]]></content>
      <tags>
        <tag>runtime, KVO</tag>
      </tags>
  </entry>
</search>